#! /usr/bin/python
import os
import fishmake
import pybase.config as PyConfig
import pybase.dir    as PyDir
import pybase.rcs    as PyRCS
import pybase.util   as PyUtil
import pybase.set    as PySet

def retrieveCode(target, codebase):
	(name, url) = codebase
	target_dir = os.path.join(target, name)
	if not os.path.isdir(target_dir):
		PyRCS.clone(url, target_dir)
	else:
		PyRCS.update(target_dir)
	return target_dir

class FishMake():
	def __init__(self, config={}, defaults={}):
		cli_config  = PyConfig.CLIConfig()
		sys_config  = PyConfig.SysConfig()
		self.config = PyConfig.Config()
		self.config.merge(defaults)
		self.config.merge(sys_config)
		self.config.merge(cli_config)
		self.config.merge(config)
		self.config.merge(PyConfig.FileConfig(".fishmake"))

	## We have to detect the applicaiton folders and generate base app
	## configurations here. Caling doConfigure will fill in the blanks.
	## Once we do that we can setup the tool chains
	def configure(self):
		## 0: For each src app
		##    0a: Checkout/update the src
		## 1: For each app
		##    1a: Generate an app config.
		##    1b: For each dependency
		##        1b1: Checkout/update the dependency
		## 2: Configure external toolchains.
		##    2a: Any app that is used by an external toolchain is to not
		##        be compiled by fishmake.
		## 3: Configure apps for tool chains
		## 4: Determine build order
		print "Configuring"

		app_dirs = [retrieveCode(self.config.get("DEP_DIR", "dep"), codebase) for codebase in self.config.get("DEPENDENCIES", [])] + \
			PyDir.getDirDirs(self.config["SRC_DIR"])

		apps_byName = {}
		## For each app
		for app_dir in app_dirs:
			## Generate config
			t_appconfig = fishmake.AppConfig(app_dir)
			apps_byName[t_appconfig.name] = t_appconfig

			## For each dependency
			dep_dirs = [retrieveCode(self.config.get("DEP_DIR", "dep"), codebase) for codebase in t_appconfig.get("DEPENDENCIES", [])]
			for dep_dir in dep_dirs:
				if dep_dir in app_dirs:
					continue
				app_dirs.append(dep_dir)

		self.config["INCLUDE_DIRS"] = self.config.getDirs("INCLUDE_DIRS") + PyDir.findDirsByName("include")
		self.config["LIB_DIRS"]     = self.config.getDirs("LIB_DIRS")     + PyDir.findDirsByName("lib")

		tcs_byName          = {}
		appNames_by_tcName  = {}
		tcNames_by_appName  = {}
		t_apps_byName       = dict(apps_byName)
		## Configure External ToolChains
		for ext_tc in fishmake.ExternalToolChains:
			tc = ext_tc.ToolChain()
			print "==>", tc.getName()
			res = tc.configure(self.config, t_apps_byName.values())
			if isinstance(res, list) and res != []:
				tcs_byName[tc.getName()]         = tc
				appNames_by_tcName[tc.getName()] = res
				for appName in res:
					del t_apps_byName[appName]
					if appName in tcNames_by_appName:
						tcNames_by_appName[appName].append(tc.getName())
					else:
						tcNames_by_appName[appName] = [tc.getName()]

		for int_tc in fishmake.InternalToolChains:
			tc = int_tc.ToolChain()
			print "==>", tc.getName()
			res = tc.configure(self.config, t_apps_byName.values())
			if isinstance(res, list) and res != []:
				tcs_byName[tc.getName()]         = tc
				appNames_by_tcName[tc.getName()] = res
				for appName in res:
					if appName in tcNames_by_appName:
						tcNames_by_appName[appName].append(tc.getName())
					else:
						tcNames_by_appName[appName] = [tc.getName()]

		## We need to determine build order for tool chains.
		tc_priorities  = {x.name : PySet.Set(x.prerequisiteTools()) for x in tcs_byName.values()}
		app_priorities = {x.name : PySet.Set(x.prerequisiteApps())  for x in apps_byName.values()}
		
		## Get tool chains that apps depend on 
		tc_app_priori = {}
		for app_priori in app_priorities:
			tc_app_priori[app_priori] = PySet.Set()
			for app in app_priorities[app_priori]:
				tc_app_priori[app_priori].add(tcNames_by_appName[app])

		## Remove toolchains that build the app.
		for app in tc_app_priori:
			tc_app_priori[app].remove(tcNames_by_appName[app])
	
		app_tc_priori = {x : PySet.Set() for x in tcs_byName.keys()}
		for app in tc_app_priori:
			for tc in tcNames_by_appName[app]:
				app_tc_priori[tc].add(tc_app_priori[app])

		tool_chain_order = PyUtil.determinePriority(app_tc_priori)
		self.tool_chains = [tcs_byName[x] for x in tool_chain_order]

	def build(self):
		print "Building"
		for tool_chain in self.tool_chains:
			print "==>", tool_chain.name
			tool_chain.build()

	def install(self):
		print "Installing"
		for nix_dir in fishmake.NIXDirs:
			tnix_dir = PyDir.makeDirAbsolute(os.path.join(self.config.get("INSTALL_PREFIX", "install"), nix_dir))
			if not os.path.exists(tnix_dir):
				os.makedirs(tnix_dir)
		for tool_chain in self.tool_chains:
			print "==>", tool_chain.name
			tool_chain.install()

	def doc(self):
		print "Documenting"
		for tool_chain in self.tool_chains:
			print "==>", tool_chain.name
			tool_chain.doc()

def main():
	cli = PyConfig.CLIConfig()

	defaults = [
		("BUILD_DIR",      "build"),
		("SRC_DIR",        "src"),
		("INSTALL_PREFIX", "install"),
		("DOC_DIR",        "doc")
	]

	x = 1;
	extraToolChains = []
	while x in cli:
		extraToolChains.append(cli[x])
		x += 1

	fishmake.addToolChains(extraToolChains)

	fish = FishMake(**{"defaults" : defaults})
	fish.configure()
	if   cli[0] == "clean":
		return fish.clean()
	elif cli[0] == "build" or cli[0] == "compile":
		return fish.build()
	elif cli[0] == "install":
		return fish.install()
	elif cli[0] == "doc":
		return fish.doc()
	elif cli[0] == "test":
		return 0
	else:
		print "Usage: fishmake <clean|build|compile|install|doc> [ToolChain[s]]"
		return 0

main()