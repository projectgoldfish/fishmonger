#! /usr/bin/python

import fishmake

from   pybase.config import Config as PyConfig
import pybase.util   as PyUtil
import pybase.dir    as PyDir
import pybase.git    as PyGit

import pyerl         as PyErl

import os, os.path, sys, subprocess, shutil

PyConfig.init(".fishmake", fishmake.Defaults)

def del_files(tmp_files):
	for t_file in tmp_files:
		if os.path.isfile(t_file):
			os.remove(t_file)

def getDirs(type, root = PyConfig["SRC_DIR"]):
	try:
		found_dirs = []
		dirs = os.listdir(root)
		for dir in dirs:
			if dir[0] == ".":
				continue
	
			dir = os.path.join(root, dir)
			if not os.path.isdir(dir):
				continue
	
			dir = PyDir.makeDirAbsolute(dir)		
			if type == "apps":
				found_dirs.append(PyDir.makeDirAbsolute(os.path.join(dir)))
			else:
				if os.path.basename(dir) == type:
					found_dirs.append(PyDir.makeDirAbsolute(dir))
				else:
					found_dirs += getDirs(type, os.path.join(root, dir))
		return found_dirs
	except:
		return []

def makeRepoTuple(repository):
	repo_tuple    = PyErl.PyErlTuple()
	repo_tuple.appendChild(PyErl.PyErlAtom(repository["Type"]))
	repo_tuple.appendChild(PyErl.PyErlString(repository["URL"]))
	if "Branch" in repository:
		if type(repository["Branch"]) is dict:
			branch_tuple    = PyErl.PyErlTuple()
			branch_tuple.appendChild(PyErl.PyErlAtom(repository["Branch"]["Type"]))
			branch_tuple.appendChild(PyErl.PyErlString(repository["Branch"]["Revision"]))
			repo_tuple.appendChild(branch_tuple)
		else:
			repo_tuple.appendChild(PyErl.PyErlString(repository["Branch"]))
	return repo_tuple

def genConfigFile():
	doc         = PyErl.PyErlDocument()
	expressions = PyErl.PyErlList()
	config_file = os.path.join(PyConfig["INSTALL_DIR"], "etc/" + PyConfig["APP_MAIN"] + ".config.default")
	for app_dir in PyConfig["APP_DIRS"]:
		app        = os.path.basename(app_dir)
		app_config = os.path.join(app_dir, "etc/" + app + ".config")
		if os.path.isfile(app_config):
			terms = PyErl.parse_file(app_config)
			expressions.appendChild(terms)

	doc.appendChild(expressions)
	PyErl.write_file(config_file, doc)

## gen_cookie(dict()) -> None
## Generates the cookie file
def genCookie():
	file_name = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "var/run/.cookie"))
	
	try:
		os.remove(file_name)
	except OSError, e:
		pass

	file = open(file_name, "w")
	file.write(PyConfig["APP_COOKIE"])
	file.close()
	PyUtil.shell("chmod a-x "  + file_name)
	PyUtil.shell("chmod a-w "  + file_name)
	PyUtil.shell("chmod og-r " + file_name)

## Look at the applications entry of the app.
## If we have app.app in our intall directory then
## get it's apps as well.
## If we don't assume it's a native app.
def getApps(app):
	apps = []
	
	app_file = PyDir.find(app + ".app", PyConfig["INSTALL_DIR"])
	if not app_file:
		app_file = PyDir.find(app + ".app", "/usr/lib/erlang") ## Search in a nix install
		if not app_file:
			app_file = PyDir.find(app + ".app", "/usr/local/lib/erlang") ## Search in an OSX install
			if not app_file:
				return [app]

	(doc, ) = PyErl.parse_file(app_file),

	tuples = doc.getElementsByTagName("tuple")
	tuple = None
	for ttuple in tuples:
		if ttuple[0].to_string() == "applications":
			tuple = ttuple
			break

	if tuple == None:
		return [app]

	for dapp in tuple[1]:
		tapps = getApps(dapp.to_string())
		for tapp in tapps:
			if not tapp in apps:
				 apps.append(tapp)
	apps.append(app)
	return apps

## gen_shell_script(dict()) -> None
## Generates a shell script that will start the system
## or attach to a runnign node.
def genShellScript():
	install_dir = PyDir.makeDirAbsolute(PyConfig["INSTALL_DIR"])

	start_apps  = ""
	apps        = getApps(PyConfig["APP_MAIN"])

	for app in apps:
		start_apps += "-eval \"application:start(" + app + ")\" "

	cookie_file = os.path.join(install_dir, "var/run/.cookie")
	file_name   = os.path.join(install_dir, "bin/" + PyConfig["APP_NAME"])
	erl_dirs    = os.path.join(install_dir, "lib/erlang/lib/*/ebin")
	erl_deps    = os.path.join(install_dir, "lib/erlang/lib/*/deps/*/ebin")
	config_file = os.path.join(install_dir, "etc/" + PyConfig["APP_NAME"] + ".config")
	file        = open(file_name, "w")
	file.write("#! /bin/bash\n")
	file.write("erl -pa " + erl_dirs + " -pa " + erl_deps + " -name " + PyConfig["APP_NAME"] +  "@`hostname -f` -setcookie \"`cat " + cookie_file + "`\" -config " + config_file +  " " + start_apps)
	file.close()
	PyUtil.shell("chmod a+x " + file_name)


def genShellConnectScript():
	install_dir = PyDir.makeDirAbsolute(PyConfig["INSTALL_DIR"])

	cookie_file = os.path.join(install_dir, "var/run/.cookie")
	file_name   = os.path.join(install_dir, "bin/" + PyConfig["APP_NAME"] + "-connect")
	erl_dirs    = os.path.join(install_dir, "lib/erlang/lib/*/ebin")
	erl_deps    = os.path.join(install_dir, "lib/erlang/lib/*/debs/*/ebin")

	file        = open(file_name, "w")
	file.write("#! /bin/bash\n")
	file.write("erl -remsh " + PyConfig["APP_NAME"] + "@`hostname -f` -pa " + erl_dirs + " -pa " + erl_deps + " -name " + PyConfig["APP_NAME"] + "-shell-$$ -setcookie \"`cat " + cookie_file + "`\"")
	file.close()
	PyUtil.shell("chmod a+x " + file_name)

def genShellEnvScript():
	install_dir = PyDir.makeDirAbsolute(PyConfig["INSTALL_DIR"])
	
	cookie_file = os.path.join(install_dir, "var/run/.cookie")
	file_name   = os.path.join(install_dir, "bin/" + PyConfig["APP_NAME"] + "-env")
	erl_dirs    = os.path.join(install_dir, "lib/erlang/lib/*/ebin")
	erl_deps    = os.path.join(install_dir, "lib/erlang/lib/*/debs/*/ebin")
	config_file = os.path.join(install_dir, "etc/" + PyConfig["APP_NAME"] + ".config")

	file        = open(file_name, "w")
	file.write("#! /bin/bash\n")
	file.write("erl -pa " + erl_dirs + " -pa " + erl_deps + " -name " + PyConfig["APP_NAME"] + "-shell-$$ -setcookie \"`cat " + cookie_file + "`\" -config " + config_file)
	file.close()
	PyUtil.shell("chmod a+x " + file_name)

## clean() -> integer()
## Cleans the copiled bits.
def clean():
	print "Cleaning"
	
	return Res

## compile(string()) -> integer()
## Takes the text for the rebar config file and compiles the system with it.
## returns the success/fail code.
def compile():
	print "Compiling"
	res = 0

	for app_dir in PyConfig["COMPILERS"]:
		print "==>", os.path.basename(app_dir)

		src_dir = os.path.join(app_dir, "src")

		types = []
		for compiler in PyConfig["COMPILERS"][app_dir]:
			res = compiler.compile(app_dir)
			if not res == 0:
				return res	

	print "Compilation done"

	return res

## build(dict()) -> integer()
## Builds the compiled code into an app hierarchy
def install():
	if not PyConfig.verify(["APP_NAME", "APP_MAIN", "APP_COOKIE"]):
		print "Error in configuration. Unable to install"
		return 255

	print "Installing", PyConfig["APP_NAME"]

	print "==> Making directories..."
	for nix_dir in fishmake.NIXDirs:
		tnix_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], nix_dir))
		if not os.path.exists(tnix_dir):
			os.makedirs(tnix_dir)
	print "==> Directories made..."

	install_bin_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "bin"))
	install_lib_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "lib"))
	install_var_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "var"))

	for app_dir in PyConfig["APP_DIRS"]:
		basename = os.path.basename(app_dir)
		bin_dir  = PyDir.makeDirAbsolute(os.path.join(app_dir, "bin"))
		doc_dir  = PyDir.makeDirAbsolute(os.path.join(app_dir, "doc"))
		var_dir  = PyDir.makeDirAbsolute(os.path.join(app_dir, "var"))

		print "==> Installing", basename

		if app_dir in PyConfig["COMPILERS"]:
			for compiler in PyConfig["COMPILERS"][app_dir]:
				print "==>"
				res = compiler.install(app_dir)
				if not res == 0:
					print "Problem installing ", app_dir, res

		print "====> Copying content..."
		if os.path.exists(var_dir):
			PyDir.copytree(var_dir, install_var_dir)
		print "====> Content copied!"
		
		## Install documentation
		if os.path.exists(doc_dir):
			install_doc_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "doc/" + basename + "-" + PyConfig["APP_VERSION"]))
			if os.path.exists(install_doc_dir):
				PyUtil.shell("rm -rf " + install_doc_dir)
			shutil.copytree(doc_dir, install_doc_dir)	
	
	print "==> Installing dependencies"
	## Create the Dependencies
	dep_dirs    = getDirs("apps", "deps")
	for dep_dir in dep_dirs:
		dep = os.path.basename(dep_dir)
		install_erl_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "lib/erlang/lib/" + dep))

		## Create the erlang lib directory
		if not os.path.exists(install_erl_dir):
			os.makedirs(install_erl_dir)

		print "==> Installing", dep
		## Clear conflicting versions
		if os.path.exists(install_erl_dir):
			PyUtil.shell("rm -rf " + install_erl_dir)

		for erl_dir in fishmake.ErlDirs:
			src_dir = os.path.join(dep_dir, erl_dir)
			erl_dir = os.path.join(install_erl_dir, erl_dir)
			if os.path.exists(src_dir):
				shutil.copytree(src_dir, erl_dir)

	print "==> Dependencies installed"
	print "==> Generating scripts"
	genShellScript()
	genShellConnectScript()
	genShellEnvScript()
	print "==> Scripts generated"
	print "==> Baking cookie"
	genCookie()
	print "==> Cookie baked"
	print "==> Generating configuration file"
	genConfigFile()
	print "==> Configuration file generated"
	print "==> Reticulating splines"
	print "==> Splines reticulated"

## configure() -> no_return()
## Explores the SRC_DIR directory and generates the appropriate
##     rebar config
def configure():
	PyConfig["APP_DIRS"]      = PyConfig["APP_DIRS"].split(":") + getDirs("apps")
	
	PyConfig["LIB_DIRS"]      = PyConfig["LIB_DIRS"].split(":")
	PyConfig["INCLUDE_DIRS"]  = PyConfig["INCLUDE_DIRS"].split(":")

	PyConfig["EXT_DEPS"]      = PyConfig["EXT_DEPS"].split(":")

	if os.path.isdir(PyConfig["EXT_DEPS_DIR"]):
		for dir in os.listdir(PyConfig["EXT_DEPS_DIR"]):
			dir = os.path.join(PyConfig["EXT_DEPS_DIR"], dir)
			if os.path.isdir(dir):
				if not dir in PyConfig["EXT_DEPS"]:
					PyConfig["EXT_DEPS"].append(dir)

	## Get the include dirs for this project.
	dirs = getDirs("include")
	for dir in PyConfig["LIB_DIRS"]:
		dirs += getDirs("include", dir)
	for dir in PyConfig["EXT_DEPS"]:
		dirs += getDirs("include", dir)
	PyConfig["INCLUDE_DIRS"] += dirs

	## Detect compilers to use
	compilers = {}

	print fishmake.compilers

	for app_dir in PyConfig["APP_DIRS"]:
		if app_dir == "":
			continue

		types      = []
		tcompilers = []

		src_dir = os.path.join(app_dir, "src")

		for compiler in fishmake.compilers:
			try:
				types = compiler.getFileTypes()
			except:
				types = []
			if PyDir.findFilesByExts(types, src_dir):
				tcompilers.append(compiler)
		compilers[app_dir] = tcompilers
	PyConfig["COMPILERS"] = compilers


def main():
	configure()
	print PyConfig
	if   PyConfig[0] == "clean":
		return clean()
	elif PyConfig[0] == "compile":
		compile()
	elif PyConfig[0] == "install":
		install()
	else:
		print "Usage: fishmake <clean|compile|install>"

main()