#! /usr/bin/python
import os
import fishmake
import pybase.config as PyConfig
import pybase.dir    as PyDir
import pybase.rcs    as PyRCS
import pybase.util   as PyUtil
import pybase.set    as PySet

def retrieveCode(target, codebase):
	(name, url) = codebase
	target_dir = os.path.join(target, name)
	if not os.path.isdir(target_dir):
		PyRCS.clone(url, target_dir)
	else:
		PyRCS.update(target_dir)
	return target_dir

class FishMake():
	def __init__(self, config={}, defaults={}):
		cli_config  = PyConfig.CLIConfig()
		sys_config  = PyConfig.SysConfig()
		self.config = PyConfig.Config()
		self.config.merge(defaults)
		self.config.merge(sys_config)
		self.config.merge(cli_config)
		self.config.merge(config)
		self.config.merge(PyConfig.FileConfig(".fishmake"))

	## We have to detect the applicaiton folders and generate base app
	## configurations here. Caling doConfigure will fill in the blanks.
	## Once we do that we can setup the tool chains
	def configure(self):
		## 0: For each src app
		##    0a: Checkout/update the src
		## 1: For each app
		##    1a: Generate an app config.
		##    1b: For each dependency
		##        1b1: Checkout/update the dependency
		## 2: Configure external toolchains.
		##    2a: Any app that is used by an external toolchain is to not
		##        be compiled by fishmake.
		## 3: Configure apps for tool chains
		## 4: Determine build order

		app_dirs = [retrieveCode(self.config.get("DEP_DIR", "dep"), codebase) for codebase in self.config.get("DEPENDENCIES", [])] + \
			PyDir.getDirDirs(self.config["SRC_DIR"])

		apps_byName = {}
		## For each app
		for app_dir in app_dirs:
			## Generate config
			t_appconfig = fishmake.AppConfig(app_dir)
			apps_byName[t_appconfig.name] = t_appconfig

			## For each dependency
			dep_dirs = [retrieveCode(self.config.get("DEP_DIR", "dep"), codebase) for codebase in t_appconfig.get("DEPENDENCIES", [])]
			for dep_dir in dep_dirs:
				if dep_dir in app_dirs:
					continue
				app_dirs.append(dep_dir)

		tcs_byName          = {}
		appNames_by_tcName  = {}
		tcNames_by_appName  = {}
		t_apps_byName       = dict(apps_byName)
		## Configure External ToolChains
		for ext_tc in fishmake.ExternalToolChains:
			tc = ext_tc.ToolChain()
			print "==>", tc.getName()
			res = tc.configure(self.config, t_apps_byName.values())
			if isinstance(res, list) and res != []:
				tcs_byName[tc.getName()]         = tc
				appNames_by_tcName[tc.getName()] = res
				for appName in res:
					del t_apps_byName[appName]
					if appName in tcNames_by_appName:
						tcNames_by_appName[appName].append(tc.getName())
					else:
						tcNames_by_appName[appName] = [tc.getName()]

		for int_tc in fishmake.InternalToolChains:
			tc = int_tc.ToolChain()
			print "==>", tc.getName()
			res = tc.configure(self.config, t_apps_byName.values())
			if isinstance(res, list) and res != []:
				tcs_byName[tc.getName()]         = tc
				appNames_by_tcName[tc.getName()] = res
				for appName in res:
					if appName in tcNames_by_appName:
						tcNames_by_appName[appName].append(tc.getName())
					else:
						tcNames_by_appName[appName] = [tc.getName()]

		## We need to determine build order for tool chains.
		tc_priorities  = {}
		app_priorities = {}
		for x in tcs_byName.values():
			tc_priorities[x.name]  = x.prerequisiteTools()
			
		for x in apps_byName.values():
			app_priorities[x.name] = x.prerequisiteApps()

		## We have tool chain orders and app orders
		## We need to generate a mapping of toolchains -> apps that respect these.
		tc_apps = {x : PySet.Set(appNames_by_tcName[x]) for x in appNames_by_tcName.keys()}
		print "tc_prio", tc_priorities
		for tc in tc_priorities:
			print "tc", tc
			for tc_p in tc_priorities[tc]:
				print "tc_p", tc_p
				tc_apps[tc].add(appNames_by_tcName[tc_p])

		print appNames_by_tcName
		print tc_priorities
		print "TCAPP", tc_apps


		## We need to determine our priorities. 
		## Get all tools 0 prereqs
		## For each tool get a list of apps
		## sort lists:

		tc_order = []
		while tc_priorities != {}:
			tc_addable = []
			for tc in tc_priorities:
				if tc_priorities[tc] == []:
					tc_addable.append(tc)
			for tc in tc_addable:
				del tc_priorities[tc]

			## We now need to figure out the order these should be run
			while tc_addable != []:
				print "TPC", tc_priorities
				print "TCA", tc_addable
				app_lists = []
				for tc in tc_addable:
					app_lists.append(tc_apps[tc])
				print app_lists
				break
				pass
			break





	def build(self):
		print "Building"
		for tool_chain in self.tool_chains:
			print "==>", tool_chain.name
			tool_chain.build()

	def install(self):
		print "Installing"
		for nix_dir in fishmake.NIXDirs:
			tnix_dir = PyDir.makeDirAbsolute(os.path.join(self.config.get("INSTALL_PREFIX", "install"), nix_dir))
			if not os.path.exists(tnix_dir):
				os.makedirs(tnix_dir)
		for tool_chain in self.tool_chains:
			print "==>", tool_chain.name
			tool_chain.install()

	def doc(self):
		print "Documenting"
		for tool_chain in self.tool_chains:
			print "==>", tool_chain.name
			tool_chain.doc()

def main():
	cli = PyConfig.CLIConfig()

	defaults = [
		("BUILD_DIR",      "build"),
		("SRC_DIR",        "src"),
		("INSTALL_PREFIX", "install"),
		("DOC_DIR",        "doc")
	]

	x = 1;
	extraToolChains = []
	while x in cli:
		extraToolChains.append(cli[x])
		x += 1

	fishmake.addToolChains(extraToolChains)

	fish = FishMake(**{"defaults" : defaults})
	fish.configure()
	if   cli[0] == "clean":
		return fish.clean()
	elif cli[0] == "build" or cli[0] == "compile":
		return fish.build()
	elif cli[0] == "install":
		return fish.install()
	elif cli[0] == "doc":
		return fish.doc()
	elif cli[0] == "test":
		return 0
	else:
		print "Usage: fishmake <clean|build|compile|install|doc> [ToolChain[s]]"
		return 0

main()