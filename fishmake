#! /usr/bin/python

from   pybase.config import Config as PyConfig
import pybase.util   as PyUtil
import pybase.dir    as PyDir
import pybase.git    as PyGit

import pyerl         as PyErl

import os, os.path, sys, subprocess, shutil

## Directories found in a built erlang src dir.
ErlDirs    = ["doc", "ebin", "priv"]

## Directories that a built app should contain.
NIXDirs    = ["bin", "doc", "etc", "lib", "lib/erlang/lib", "log", "sbin", "var", "var/run"]

## Initialize config
PyConfig.init("fishmake.config", {
	"INCLUDE_DIRS"      : os.getenv("ERL_INCLUDE_DIRS",  "."),
	"SOURCE_DIR"        : os.getenv("ERL_SRC_DIR",       "esrc"),
	"ERL_VERSION"       : os.getenv("ERL_VERSION",       "16"),

	"INSTALL_DIR"       : os.getenv("INSTALL_DIR",       "install"),
	"REBAR_CONFIG_FILE" : os.getenv("REBAR_CONFIG",      ".rebar.config"),
	
	"APP_NAME"          : False,
	"APP_MAIN"          : False,
	
	"VERSION"           : PyGit.getVersion(),
	"ID"                : PyGit.getId(),

	"APP_DIRS"          : [],
	"EXT_DEPS"          : [],
	"MODULE_DIRS"       : [],	

	"REBAR_CONFIG"      : "",
	"COOKIE"            : ""
})

def del_files(tmp_files):
	for t_file in tmp_files:
		if os.path.isfile(t_file):
			os.remove(t_file)

def getAppDirs(root = PyConfig["SOURCE_DIR"]):
	app_dirs = []
	(root, dirs, files) = os.walk(root).next()
	for dir in dirs:
		if dir[0] != ".":
			app_dirs.append(PyDir.makeDirAbsolute(root + "/" + dir))
	return app_dirs

def getDirs(type, root = PyConfig["SOURCE_DIR"]):
	if type == "apps":
		return getAppDirs(root)
	else:	
		dirs = []
		for (dir, a, b) in os.walk(root):
			if type in dir:
				dirs.append(PyDir.makeDirAbsolute(dir))
		return dirs

def makeRepoTuple(repository):
	repo_tuple    = PyErl.PyErlTuple()
	repo_tuple.appendChild(PyErl.PyErlAtom(repository["Type"]))
	repo_tuple.appendChild(PyErl.PyErlString(repository["URL"]))
	if "Branch" in repository:
		if type(repository["Branch"]) is dict:
			branch_tuple    = PyErl.PyErlTuple()
			branch_tuple.appendChild(PyErl.PyErlAtom(repository["Branch"]["Type"]))
			branch_tuple.appendChild(PyErl.PyErlString(repository["Branch"]["Revision"]))
			repo_tuple.appendChild(branch_tuple)
		else:
			repo_tuple.appendChild(PyErl.PyErlString(repository["Branch"]))
	return repo_tuple

## generateRebarConfig() -> string()
## Takes a list of directories to build and returns the text for the rebar 
## config file.
def generateRebarConfig():
	output      = ""

	expressions = []

	src_dirs    = PyErl.term("{sub_dirs, []}.")
	print src_dirs
	print src_dirs.to_string()
	print src_dirs[1]
	for app_dir in PyConfig["APP_DIRS"]:
		src_dirs[1].appendChild(PyErl.PyErlString(app_dir))
	expressions.append(src_dirs)

	erl_opts    = PyErl.term("{erl_opts, []}.")
	for include_dir in PyConfig["INCLUDE_DIRS"]:
		include_tuple = PyErl.term("{i, \"" + include_dir + "\"}.")
		erl_opts[1].appendChild(include_tuple)
	erl_opts[1].appendChild(PyErl.PyErlAtom("debug_info"))
	erl_opts[1].appendChild(PyErl.PyErlAtom("fail_on_warning"))
	expressions.append(erl_opts)

	required = PyErl.term("{require_otp_vsn, " + "\"R" + PyConfig["ERL_VERSION"] + "\"}.")
	expressions.append(required)

	deps    = PyErl.term("{deps, []}.")
	for dep in PyConfig["EXT_DEPS"]:
		dep_tuple = PyErl.PyErlTuple()
		dep_tuple.appendChild(PyErl.PyErlAtom(dep["Name"]))
		dep_tuple.appendChild(PyErl.PyErlString(dep["Version"]))
		dep_tuple.appendChild(makeRepoTuple(dep["Repository"]))
		deps[1].appendChild(dep_tuple)
	expressions.append(deps)
	
	output = ""
	for expression in expressions:
		output += expression.to_string() + ".\n"

	return output

def addVersion(app_src):
	arg_list = app_src.getElementsByTagName("list")[0]
	
	## If a vsn has already been specified leave it.
	for term in arg_list:
		if hasattr(term, '__iter__') and term[0].getValue == "vsn":
			return

	version_tuple = PyErl.PyErlTuple()
	version_tuple.appendChild(PyErl.PyErlAtom("vsn"))
	version_tuple.appendChild(PyErl.PyErlString(PyConfig["VERSION"]))
	arg_list.appendChild(version_tuple)
	return app_src

def addId(app_src):
	arg_list = app_src.getElementsByTagName("list")[0]
	
	## If a vsn has already been specified leave it.
	for term in arg_list:
		if hasattr(term, '__iter__') and term[0].getValue == "id":
			return

	id_tuple = PyErl.PyErlTuple()
	id_tuple.appendChild(PyErl.PyErlAtom("id"))
	id_tuple.appendChild(PyErl.PyErlString(PyConfig["ID"]))
	arg_list.appendChild(id_tuple)
	return app_src

def defaultAppSrc(app):
	doc   = PyErl.PyErlDocument()
	expr  = PyErl.PyErlExpression()
	tuple = PyErl.PyErlTuple(PyErl.PyErlAtom("application"))
	args  = PyErl.PyErlList()
	
	doc.appendChild(expr)
	expr.appendChild(tuple)
	tuple.appendChild(PyErl.PyErlAtom(app))
	tuple.appendChild(args)

	version_tuple = PyErl.PyErlTuple()
	version_tuple.appendChild(PyErl.PyErlAtom("vsn"))
	version_tuple.appendChild(PyErl.PyErlString(PyConfig["VERSION"]))

	args.appendChild(version_tuple)
	
	return doc

## gen_app_src(dct()) -> [string()]
## Looks in each app dir for a $APP.app.src file
## Generates a default one if it does not exist.
## These are deleted afterwards
def genAppSrc():
	generated = []

	print PyConfig
	print PyConfig["APP_DIRS"]

	for app_dir in PyConfig["APP_DIRS"]:
		app      = os.path.basename(app_dir)
		app_fish = app_dir + "/src/"  + app + ".app.fish"
		app_src  = app_dir + "/src/"  + app + ".app.src"
		app_file = app_dir + "/ebin/" + app + ".app"
		generated.append(app_src)

		src = ""
		if not os.path.isfile(app_fish):
			generated.append(app_file)
			src = defaultAppSrc(app)
		else:
			src = PyErl.parse_file(app_fish)
			## The .fish file is a base configuration.
			## We need to generate and append some default valeus to it
			## such as build number, and, uh, others to be determined...
			src = addVersion(src)
			src = addId(src)
		PyErl.write_file(app_src, src)

	return generated

def genConfigFile():
	doc         = PyErl.PyErlDocument()
	expressions = PyErl.PyErlList()
	config_file = os.path.join(PyConfig["INSTALL_DIR"], "etc/" + PyConfig["APP_MAIN"] + ".config.default")
	for app_dir in PyConfig["APP_DIRS"]:
		app        = os.path.basename(app_dir)
		app_config = os.path.join(app_dir, "etc/" + app + ".config")
		if os.path.isfile(app_config):
			terms = PyErl.parse_file(app_config)
			expressions.appendChild(terms)

	doc.appendChild(expressions)
	PyErl.write_file(config_file, doc)

## gen_cookie(dict()) -> None
## Generates the cookie file
def genCookie():
	file_name = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "var/run/.cookie"))
	
	try:
		os.remove(file_name)
	except OSError, e:
		pass

	file = open(file_name, "w")
	file.write(PyConfig["COOKIE"])
	file.close()
	PyUtil.shell("chmod a-x "  + file_name)
	PyUtil.shell("chmod a-w "  + file_name)
	PyUtil.shell("chmod og-r " + file_name)

## gen_shell_script(dict()) -> None
## Generates a shell script that will start the system
## or attach to a runnign node.
def genShellScript():
	install_dir = PyDir.makeDirAbsolute(PyConfig["INSTALL_DIR"])

	cookie_file = os.path.join(install_dir, "var/run/.cookie")
	file_name   = os.path.join(install_dir, "bin/" + PyConfig["APP_NAME"])
	erl_dirs    = os.path.join(install_dir, "lib/erlang/lib/*/ebin")
	erl_deps    = os.path.join(install_dir, "lib/erlang/lib/*/debs/*/ebin")
	config_file = os.path.join(install_dir, "etc/" + PyConfig["APP_NAME"] + ".config")

	print install_dir, file_name

	execute     = "-eval \"application:start(" + PyConfig["APP_NAME"] + ")\""

	file        = open(file_name, "w")
	file.write("#! /bin/bash\n")
	file.write("erl -pa " + erl_dirs + " -pa " + erl_deps + " -name " + PyConfig["APP_NAME"] +  "@`hostname -f` -setcookie \"`cat " + cookie_file + "`\" -config " + config_file +  " " + execute)
	file.close()
	PyUtil.shell("chmod a+x " + file_name)


def genShellConnectScript():
	install_dir = PyDir.makeDirAbsolute(PyConfig["INSTALL_DIR"])

	cookie_file = os.path.join(install_dir, "var/run/.cookie")
	file_name   = os.path.join(install_dir, "bin/" + PyConfig["APP_NAME"] + "-connect")
	erl_dirs    = os.path.join(install_dir, "lib/erlang/lib/*/ebin")
	erl_deps    = os.path.join(install_dir, "lib/erlang/lib/*/debs/*/ebin")

	file        = open(file_name, "w")
	file.write("#! /bin/bash\n")
	file.write("erl -remsh " + PyConfig["APP_NAME"] + "@`hostname -f` -pa " + erl_dirs + " -pa " + erl_deps + " -name " + PyConfig["APP_NAME"] + "-shell-$$ -setcookie \"`cat " + cookie_file + "`\"")
	file.close()
	PyUtil.shell("chmod a+x " + file_name)

def genShellEnvScript():
	install_dir = PyDir.makeDirAbsolute(PyConfig["INSTALL_DIR"])
	
	cookie_file = os.path.join(install_dir, "var/run/.cookie")
	file_name   = os.path.join(install_dir, "bin/" + PyConfig["APP_NAME"] + "-env")
	erl_dirs    = os.path.join(install_dir, "lib/erlang/lib/*/ebin")
	erl_deps    = os.path.join(install_dir, "lib/erlang/lib/*/debs/*/ebin")
	config_file = os.path.join(install_dir, "etc/" + PyConfig["APP_NAME"] + ".config")

	file        = open(file_name, "w")
	file.write("#! /bin/bash\n")
	file.write("erl -pa " + erl_dirs + " -pa " + erl_deps + " -name " + PyConfig["APP_NAME"] + "-shell-$$ -setcookie \"`cat " + cookie_file + "`\" -config " + config_file)
	file.close()
	PyUtil.shell("chmod a+x " + file_name)

## clean() -> integer()
## Cleans the copiled bits.
def clean():
	print "Cleaning"
	rebar_config_file = PyConfig["REBAR_CONFIG_FILE"]
	file = open(rebar_config_file, "w")
	if not file:
		return 255
	file.write(PyConfig["REBAR_CONFIG"])
	file.close()

	TmpFiles = gen_app_src(Config)
	TmpFiles.append(rebar_config_file)

	Res  = PyUtil.shell("rebar --config " + rebar_config_file + " clean")
	Res  = PyUtil.shell("rebar --config " + rebar_config_file + " delete-deps")

	del_files(TmpFiles)
	return Res

## compile(string()) -> integer()
## Takes the text for the rebar config file and compiles the system with it.
## returns the success/fail code.
def compile():
	print "Compiling"
	
	tmp_files = genAppSrc()

	res  = PyUtil.shell("rebar --config " + PyConfig["REBAR_CONFIG_FILE"] + " get-deps")
	res  = PyUtil.shell("rebar --config " + PyConfig["REBAR_CONFIG_FILE"] + " compile")

	del_files(tmp_files)
	return res

## build(dict()) -> integer()
## Builds the compiled code into an app hierarchy
def install():
	if not PyConfig.verify(["APP_NAME", "APP_MAIN", "COOKIE"]):
		print "Error in configuration. Unable to install"
		return 255

	print "Installing", PyConfig["APP_NAME"]

	print "==> Making directories..."
	for nix_dir in NIXDirs:
		tnix_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], nix_dir))
		if not os.path.exists(tnix_dir):
			os.makedirs(tnix_dir)
	print "==> Directories made..."

	install_bin_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "bin"))
	install_lib_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "lib"))
	install_var_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "var"))

	for app_dir in PyConfig["APP_DIRS"]:
		basename = os.path.basename(app_dir)
		bin_dir  = PyDir.makeDirAbsolute(os.path.join(app_dir, "bin"))
		var_dir  = PyDir.makeDirAbsolute(os.path.join(app_dir, "var"))
		
		install_erl_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "lib/erlang/lib/" + basename + "-" + PyConfig["VERSION"]))

		print "==> Installing", basename
		print "====> Copying content..."
		if os.path.exists(var_dir):
			PyDir.copytree(var_dir, install_var_dir)
		print "====> Content copied!"
		print "====> Copying binaries..."	
		## Clear conflicting versions
		if os.path.exists(install_erl_dir):
			PyUtil.shell("rm -rf " + install_erl_dir)
		
		## Create the erlang lib directry
		if not os.path.exists(install_erl_dir):
			os.makedirs(install_erl_dir)

		for erl_dir in ErlDirs:
			src_dir = os.path.join(app_dir, erl_dir)
			erl_dir = os.path.join(install_erl_dir, erl_dir)
			if os.path.exists(src_dir):
				shutil.copytree(src_dir, erl_dir)
		print "====> Binaries copied!"
	
	print "==> Copying dependencies"
	## Create the Dependencies
	dep_dirs    = getDirs("apps", "deps")
	for dep_dir in dep_dirs:
		dep = os.path.basename(dep_dir)
		install_erl_dir = PyDir.makeDirAbsolute(os.path.join(PyConfig["INSTALL_DIR"], "lib/erlang/lib/" + dep))

		## Clear conflicting versions
		if os.path.exists(install_erl_dir):
			PyUtil.shell("rm -rf " + install_erl_dir)

		for erl_dir in ErlDirs:
			src_dir = os.path.join(dep_dir, erl_dir)
			erl_dir = os.path.join(install_erl_dir, erl_dir)
			if os.path.exists(dep_dir):
				shutil.copytree(dep_dir, erl_dir)

	print "==> Dependencies copied"
	print "==> Generating scripts"
	genShellScript()
	genShellConnectScript()
	genShellEnvScript()
	print "==> Scripts generated"
	print "==> Baking cookie"
	genCookie()
	print "==> Cookie baked"
	print "==> Generating configuration file"
	genConfigFile()
	print "==> Configuration file generated"
	print "==> Reticulating splines"
	print "==> Splines reticulated"

## configure() -> no_return()
## Explores the SOURCE_DIR directory and generates the appropriate
##     rebar config
def configure():
	PyConfig["APP_DIRS"]     = getDirs("apps")
	PyConfig["INCLUDE_DIRS"] = getDirs("include")
	PyConfig["REBAR_CONFIG"] = generateRebarConfig()

	PyConfig["COOKIE"]       = PyGit.getId()

	file = open(PyConfig["REBAR_CONFIG_FILE"], "w")
	if not file:
		return 255
	file.write(PyConfig["REBAR_CONFIG"])
	file.close()

def main():
	configure()
	if      PyConfig.get(0) == "clean":
		return clean()
	elif PyConfig.get(0) == "compile":
		compile()
	elif PyConfig.get(0) == "install":
		install()
	else:
		print "Usage: fishmake <clean|compile|install>"

main()